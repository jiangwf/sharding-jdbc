/*
 * Copyright 1999-2015 dangdang.com.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * </p>
 */

package com.dangdang.ddframe.rdb.sharding.jdbc.core.statement;

import com.dangdang.ddframe.rdb.sharding.api.rule.DataNode;
import com.dangdang.ddframe.rdb.sharding.api.rule.DataSourceRule;
import com.dangdang.ddframe.rdb.sharding.api.rule.TableRule;
import com.dangdang.ddframe.rdb.sharding.executor.type.batch.BatchPreparedStatementExecutor;
import com.dangdang.ddframe.rdb.sharding.executor.type.batch.BatchPreparedStatementUnit;
import com.dangdang.ddframe.rdb.sharding.executor.type.prepared.PreparedStatementExecutor;
import com.dangdang.ddframe.rdb.sharding.executor.type.prepared.PreparedStatementUnit;
import com.dangdang.ddframe.rdb.sharding.jdbc.adapter.AbstractPreparedStatementAdapter;
import com.dangdang.ddframe.rdb.sharding.jdbc.core.connection.ShardingConnection;
import com.dangdang.ddframe.rdb.sharding.jdbc.core.resultset.ShardingResultSet;
import com.dangdang.ddframe.rdb.sharding.merger.MergeEngine;
import com.dangdang.ddframe.rdb.sharding.parsing.parser.context.GeneratedKey;
import com.dangdang.ddframe.rdb.sharding.parsing.parser.statement.select.SelectStatement;
import com.dangdang.ddframe.rdb.sharding.routing.PreparedStatementRoutingEngine;
import com.dangdang.ddframe.rdb.sharding.routing.SQLExecutionUnit;
import com.google.common.base.Optional;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterators;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;

/**
 * ֧支持分片的预编译语句对象.
 *
 * @author zhangliang
 * @author caohao
 */
public final class ShardingPreparedStatement extends AbstractPreparedStatementAdapter {

    private static final Logger logger = LoggerFactory.getLogger(ShardingPreparedStatement.class);
    private final PreparedStatementRoutingEngine routingEngine;
    private final List<BatchPreparedStatementUnit> batchStatementUnits = new LinkedList<>();
    private final List<List<Object>> parameterSets = new LinkedList<>();
    //判断程序启动的时候解析一次
    private static boolean resolveFlag = false;
    private static boolean firstDayFlag = true;


    public ShardingPreparedStatement(final ShardingConnection shardingConnection, final String sql) {
        this(shardingConnection, sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    public ShardingPreparedStatement(final ShardingConnection shardingConnection, final String sql, final int resultSetType, final int resultSetConcurrency) {
        this(shardingConnection, sql, resultSetType, resultSetConcurrency, ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    public ShardingPreparedStatement(final ShardingConnection shardingConnection, final String sql, final int autoGeneratedKeys) {
        this(shardingConnection, sql);
        if (RETURN_GENERATED_KEYS == autoGeneratedKeys) {
            markReturnGeneratedKeys();
        }
    }

    /**
     * 动态配置分库分表中表后缀参数默认根据起始月份和当前时间所属月份 wp
     * @param shardingConnection
     * @param sql
     * @param resultSetType
     * @param resultSetConcurrency
     * @param resultSetHoldability
     */
    public ShardingPreparedStatement(final ShardingConnection shardingConnection, final String sql, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) {
        super(shardingConnection, resultSetType, resultSetConcurrency, resultSetHoldability);
        Map<String,String> yearMonthMap = new LinkedHashMap<>();
        Calendar calendar = Calendar.getInstance();
        if(calendar.get(calendar.DAY_OF_MONTH) == 1){
            if (firstDayFlag){
                resolveFlag = true;
                firstDayFlag = false;
            }
        }else {
            firstDayFlag = true;
        }
        //默认失效时间为一天
//        boolean spitTableFlag = LockUtil.lock("spitTable","parameters", ((CommonSettings) SpringUtil.getBean("commonSettings")).getSplitTableseconds());
//        if(spitTableFlag || resolveFlag){

        if(resolveFlag){
            try {
//                Date dateFrom = DateUtils.SDF1().parse("201708");
//                Date dateEnd = DateUtils.SDF1().parse(DateUtils.SDF1().format(new Date()));
                Date dateFrom = new SimpleDateFormat("yyyyMM").parse("201707");//定义起始日期
                Date dateEnd = new SimpleDateFormat("yyyyMM").parse(new SimpleDateFormat("yyyyMM").format(new Date()));//定义结束日期
                Calendar calBegin = Calendar.getInstance();
                calBegin.setTime(dateFrom);
                Calendar calEnd = Calendar.getInstance();
                calEnd.setTime(dateEnd);
                while (calEnd.after(calBegin)) {
                    // 根据日历的规则，为给定的日历字段添加或减去指定的时间量
                    calBegin.add(Calendar.MONTH, 1);
                    yearMonthMap.put((String)(new SimpleDateFormat("yyyyMM")).format(calBegin.getTime()), "");
                }
                DataSourceRule dataSourceRule = shardingConnection.getShardingContext().getShardingRule().getDataSourceRule();
                Collection<TableRule>  collection = shardingConnection.getShardingContext().getShardingRule().getTableRules();
                for (TableRule tableRule:collection){
                    if (tableRule.dynamic){
                        boolean flag = false;
                        // 201707@finance_01_001-fiancne_10_001
                        List<DataNode> listDataNode = new ArrayList();
//                        List<DataNode> actualTables = tableRule.getActualTables();
                        List<DataNode> actualTables = tableRule.getActualTablesBack();
                        for (DataNode dataNode:actualTables){
                            String table = dataNode.getTableName();
                            for(String dataBase:table.split("-")){
                                if (dataBase.contains("@")){
                                    String[] str = dataBase.split("@");
                                    Map<String,String> yearMonthMapTemp = new LinkedHashMap<>();
                                    try {
                                        if (StringUtils.isNumeric(str[0])){
                                            Date dateFromTemp = new SimpleDateFormat("yyyyMM").parse(str[0]);//定义起始日期
                                            Calendar calBeginTemp = Calendar.getInstance();
                                            calBeginTemp.setTime(dateFromTemp);
                                            Calendar calEndTemp = Calendar.getInstance();
                                            calEndTemp.setTime(dateEnd);
                                            while (calEndTemp.after(calBeginTemp)) {
                                                // 根据日历的规则，为给定的日历字段添加或减去指定的时间量
                                                calBeginTemp.add(Calendar.MONTH, 1);
                                                yearMonthMapTemp.put((String)(new SimpleDateFormat("yyyyMM")).
                                                        format(calBeginTemp.getTime()), "");
                                            }
                                        }else {
                                            throw new RuntimeException("分库分表动态参数配置错误（actual-tables），日期年月配置错误无法解析");
                                        }
                                        flag = TableRule.splitTable(str[1], listDataNode, yearMonthMapTemp, tableRule.getLogicTable(), dataSourceRule);
                                    }catch (Exception e){
                                        throw new RuntimeException("分库分表动态参数配置错误（actual-tables），程序无法解析"+e.getMessage());
                                    }finally {
                                        yearMonthMapTemp.clear();
                                    }
                                }else {
                                    flag = TableRule.splitTable(dataBase, listDataNode, yearMonthMap, tableRule.getLogicTable(), dataSourceRule);
                                }
                                if (!flag){
                                    break;
                                }
                            }
//                            历史代码暂存
//                            if (table.contains("@")){
//                                String[] str = table.split("@");
//                                Map<String,String> yearMonthMapTemp = new LinkedHashMap<>();
//                                try {
//                                    if (StringUtils.isNumeric(str[0])){
//                                        Date dateFromTemp = new SimpleDateFormat("yyyyMM").parse(str[0]);//定义起始日期
//                                        Calendar calBeginTemp = Calendar.getInstance();
//                                        calBeginTemp.setTime(dateFromTemp);
//                                        Calendar calEndTemp = Calendar.getInstance();
//                                        calEndTemp.setTime(dateEnd);
//                                        while (calEndTemp.after(calBeginTemp)) {
//                                            // 根据日历的规则，为给定的日历字段添加或减去指定的时间量
//                                            calBeginTemp.add(Calendar.MONTH, 1);
//                                            yearMonthMapTemp.put((String)(new SimpleDateFormat("yyyyMM")).format(calBeginTemp.getTime()), "");
//                                        }
//                                    }else {
//                                        throw new RuntimeException("分库分表动态参数配置错误（actual-tables），日期年月配置错误无法解析");
//                                    }
//
//                                    if (str[1].contains("-")){
//                                        flag = splitTable(str[1], listDataNode, yearMonthMapTemp, tableRule, dataSourceRule);
//                                    }else {
//                                        throw new RuntimeException("分库分表动态参数配置错误（actual-tables），库名参数配置错误无法解析");
//                                    }
//                                }catch (Exception e){
//                                    throw new RuntimeException("分库分表动态参数配置错误（actual-tables），程序无法解析"+e.getMessage());
//                                }finally {
//                                    yearMonthMapTemp.clear();
//                                }
//                            }else if (table.contains("-")){
//                                flag = splitTable(table, listDataNode, yearMonthMap, tableRule, dataSourceRule);
//                            }

                        }
                        if (flag){
//                            actualTables.clear();;
                            tableRule.setActualTables(listDataNode);
                        }
                    }
                }
            } catch (ParseException e) {
                logger.error("转换分库分表月份配置失败"+e.getMessage());
                throw new RuntimeException("转换分库分表月份配置失败"+e.getMessage());
            }
            resolveFlag = false;
        }
        routingEngine = new PreparedStatementRoutingEngine(sql, shardingConnection.getShardingContext());
    }



//    public boolean splitTable(String table, List listDataNode, Map<String,String> yearMonthMap, TableRule tableRule,DataSourceRule dataSourceRule){
//        if (table.contains("-")){
//            String[] dataBases = table.split("-");
//            for (String dataBase:dataBases){
//                if (dataBase != Cons.DATABASENAME && dataSourceRule.getDataSource(dataBase) != null){
//                    for (Map.Entry<String, String> entry : yearMonthMap.entrySet()) {
//                        DataNode dataNodeNew = new DataNode(dataBase,tableRule.getLogicTable()+"_"+entry.getKey());
//                        listDataNode.add(dataNodeNew);
//                    }
//                }else {
//                    throw new RuntimeException("分库分表动态参数配置错误（actual-tables），程序无法解析,数据源："+dataBase+" 不存在或者配置错误");
//                }
//            }
//            return true;
//        }
//        return false;
//    }

    @Override
    public ResultSet executeQuery() throws SQLException {
        ResultSet result;
        try {
            Collection<PreparedStatementUnit> preparedStatementUnits = route();
            List<ResultSet> resultSets = new PreparedStatementExecutor(
                    getShardingConnection().getShardingContext().getExecutorEngine(), getRouteResult().getSqlStatement().getType(), preparedStatementUnits, getParameters()).executeQuery();
            result = new ShardingResultSet(resultSets, new MergeEngine(resultSets, (SelectStatement) getRouteResult().getSqlStatement()).merge());
        } finally {
            clearBatch();
        }
        setCurrentResultSet(result);
        return result;
    }

    @Override
    public int executeUpdate() throws SQLException {
        try {
            Collection<PreparedStatementUnit> preparedStatementUnits = route();
            return new PreparedStatementExecutor(
                    getShardingConnection().getShardingContext().getExecutorEngine(), getRouteResult().getSqlStatement().getType(), preparedStatementUnits, getParameters()).executeUpdate();
        } finally {
            clearBatch();
        }
    }

    @Override
    public boolean execute() throws SQLException {
        try {
            Collection<PreparedStatementUnit> preparedStatementUnits = route();
            return new PreparedStatementExecutor(
                    getShardingConnection().getShardingContext().getExecutorEngine(), getRouteResult().getSqlStatement().getType(), preparedStatementUnits, getParameters()).execute();
        } finally {
            clearBatch();
        }
    }

    private Collection<PreparedStatementUnit> route() throws SQLException {
        Collection<PreparedStatementUnit> result = new LinkedList<>();
        setRouteResult(routingEngine.route(getParameters()));
        for (SQLExecutionUnit each : getRouteResult().getExecutionUnits()) {
            PreparedStatement preparedStatement = generatePreparedStatement(each);
            getRoutedStatements().add(preparedStatement);
            replaySetParameter(preparedStatement);
            result.add(new PreparedStatementUnit(each, preparedStatement));
        }
        return result;
    }

    private PreparedStatement generatePreparedStatement(final SQLExecutionUnit sqlExecutionUnit) throws SQLException {
        Optional<GeneratedKey> generatedKey = getGeneratedKey();
        Connection connection = getShardingConnection().getConnection(sqlExecutionUnit.getDataSource(), getRouteResult().getSqlStatement().getType());
        if (isReturnGeneratedKeys() && generatedKey.isPresent()) {
            return connection.prepareStatement(sqlExecutionUnit.getSql(), RETURN_GENERATED_KEYS);
        }
        return connection.prepareStatement(sqlExecutionUnit.getSql(), getResultSetType(), getResultSetConcurrency(), getResultSetHoldability());
    }

    @Override
    public void clearBatch() throws SQLException {
        setCurrentResultSet(null);
        clearParameters();
        batchStatementUnits.clear();
        parameterSets.clear();
    }

    @Override
    public void addBatch() throws SQLException {
        try {
            for (BatchPreparedStatementUnit each : routeBatch()) {
                each.getStatement().addBatch();
                each.mapAddBatchCount(parameterSets.size());
            }
            parameterSets.add(getParameters());
        } finally {
            setCurrentResultSet(null);
            clearParameters();
        }
    }

    @Override
    public int[] executeBatch() throws SQLException {
        try {
            return new BatchPreparedStatementExecutor(
                    getShardingConnection().getShardingContext().getExecutorEngine(), getRouteResult().getSqlStatement().getType(), batchStatementUnits, parameterSets).executeBatch();
        } finally {
            clearBatch();
        }
    }

    private List<BatchPreparedStatementUnit> routeBatch() throws SQLException {
        List<BatchPreparedStatementUnit> result = new ArrayList<>();
        setRouteResult(routingEngine.route(getParameters()));
        for (SQLExecutionUnit each : getRouteResult().getExecutionUnits()) {
            BatchPreparedStatementUnit batchStatementUnit = getPreparedBatchStatement(each);
            replaySetParameter(batchStatementUnit.getStatement());
            result.add(batchStatementUnit);
        }
        return result;
    }

    private BatchPreparedStatementUnit getPreparedBatchStatement(final SQLExecutionUnit sqlExecutionUnit) throws SQLException {
        Optional<BatchPreparedStatementUnit> preparedBatchStatement = Iterators.tryFind(batchStatementUnits.iterator(), new Predicate<BatchPreparedStatementUnit>() {

            @Override
            public boolean apply(final BatchPreparedStatementUnit input) {
                return Objects.equals(input.getSqlExecutionUnit(), sqlExecutionUnit);
            }
        });
        if (preparedBatchStatement.isPresent()) {
            return preparedBatchStatement.get();
        }
        BatchPreparedStatementUnit result = new BatchPreparedStatementUnit(sqlExecutionUnit, generatePreparedStatement(sqlExecutionUnit));
        batchStatementUnits.add(result);
        return result;
    }
}
